<meta charset="utf8" />
<head>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css">
    <script src='https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.2.1/dist/sql-wasm.js'></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@2.8.0"></script>
</head>
<html>
    <body>
        <div class="d-flex justify-content-between flex-md-row align-items-center p-3 px-md-4 mb-3 bg-white border-bottom box-shadow">
            <div>
                <h4 class="my-0 mr-md-auto font-weight-normal">CI Weather Report</h4>
                <small>Brought to you by <b>MM</b></small>
            </div>
            <div>
                <h4 class="my-0 mr-md-auto font-weight-normal" id="weather"></h4>
                <small id="description"></small>
            </div>
            <div class="form-group row">
                <label for="days" class="col-sm-6 col-form-label">Days</label>
                <select id="days" class="form-control col-sm-6">
                    <option value="3">3</option>
                    <option value="5">5</option>
                    <option value="7">7</option>
                    <option value="9">9</option>
                    <option value="14">14</option>
                    <option value="21">21</option>
                </select>
            </div>
        </div>
        <nav aria-label="breadcrumb" id="nav" hidden>
            <ol class="breadcrumb">
                <li class="breadcrumb-item"><a href="#" id="overview">Overview</a></li>
                <li class="breadcrumb-item active" aria-current="page" id="current"></li>
            </ol>
        </nav>
        <div class="container-fluid px-5">
            <div class="row">
                <div class="col-md-6">
                    <div id="t1"></div>
                </div>
                <div class="col-md-6">
                    <div id="t2"></div>
                </div>
            </div>
            <div class="row">
                <div class="col-md-12">
                    <h2 id="g1-title"></h2>
                    <canvas id="g1" style="width: 100%; height: 256px"></canvas>
                </div>
            </div>
            <div class="row">
                <div class="col-md-12">
                    <h2 id="g2-title"></h2>
                    <canvas id="g2" style="width: 100%; height: 256px"></canvas>
                </div>
            </div>
        </div>
  </body>
  <script>
    const DAY = 86400;
    const params = new URLSearchParams(window.location.search);
    const days = Number(params.get('days') || 14);
    const test = params.get('test');

    const days_select = document.getElementById("days");
    Array.from(days_select.options).forEach(o => {
        o.selected = o.value == days;
    });
    days_select.addEventListener("change", e => {
        params.set("days", e.target.value);
        history.replaceState(null, null, "?"+params.toString());
        location.reload();
    });

    if (test) {
        document.getElementById("nav").hidden = false;
        document.getElementById("current").innerHTML = test;
        document.getElementById("overview").onclick = () => {
            params.delete("test");
            history.replaceState(null, null, "?"+params.toString());
            location.reload();
        };
    } else {
        document.getElementById("nav").hidden = true;
    }

    const config = {
      locateFile: filename => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.2.1/dist/${filename}`
    };
    initSqlJs(config).then(SQL => {
        const xhr = new XMLHttpRequest();
        xhr.open('GET', 'test-results.db', true);
        xhr.responseType = 'arraybuffer';

        xhr.onload = e => {
            const uInt8Array = new Uint8Array(xhr.response);
            const db = new SQL.Database(uInt8Array);

            const since = (new Date().getTime() / 1000) - days * DAY;

            if (test) {
                top10 = []
                const rows = db.exec(`
                        SELECT context, COUNT(*) AS failed
                        FROM TestRuns
                        JOIN Tests ON Tests.run = TestRuns.id
                        WHERE time > ${since} AND Tests.failed = 1 AND Tests.testname = '${test}'
                        GROUP BY context
                        ORDER BY COUNT(*) DESC`);
                const failed = db.exec(`
                        SELECT COUNT(*) AS failed
                        FROM TestRuns
                        JOIN Tests ON Tests.run = TestRuns.id
                        WHERE time > ${since} AND Tests.failed = 1 AND Tests.testname = '${test}'`)[0].values[0][0];

                rows[0].values.forEach(row => {
                    const urls = db.exec(`
                        SELECT DISTINCT TestRuns.url
                        FROM TestRuns JOIN Tests ON TestRuns.id = Tests.run
                        WHERE testname = '${test}' AND TestRuns.context = '${row[0]}' AND failed = 1
                        ORDER BY run DESC
                        LIMIT 2`);
                    const links = urls[0].values.map(u => u[0]);
                    top10.push([row[0], ((row[1] * 100) / failed).toFixed(2), links]);
                });
                if (!top10.length)
                    top10.push([`No failures in the last ${days} days`, 0, []]);

                createTable("t1", "Most affected OSes", ["Operating system", "Fail rate (%)", "Logs"], top10);

                // Show % of failed tests per day
                const labels = [];
                const points = [];
                const yesterday = new Date();
                yesterday.setHours(0, 0, 0, 0);
                let to = new Date();
                let from = yesterday;
                for (let i = 0; i < days; i++) {
                    const failed = db.exec(`
                            SELECT (t2.count * 100.0) / COUNT(*), COUNT(*)
                            FROM Tests
                            JOIN TestRuns ON Tests.run = TestRuns.id
                            JOIN (
                                SELECT COUNT(*) as count
                                FROM Tests
                                JOIN TestRuns ON Tests.run = TestRuns.id
                                WHERE TestRuns.time > ${from.getTime() / 1000} AND TestRuns.time < ${to.getTime() / 1000} AND Tests.failed = 1 AND Tests.testname = '${test}'
                            ) AS t2
                            WHERE TestRuns.time > ${from.getTime() / 1000} AND TestRuns.time < ${to.getTime() / 1000} AND Tests.testname = '${test}'`);
                    labels.unshift(`${from.getDate()}.${from.getMonth() + 1} (${failed[0].values[0][1]} runs)`);
                    points.unshift(failed[0].values[0][0]);

                    to = new Date(yesterday);
                    to.setDate(yesterday.getDate() - i);
                    from = new Date(yesterday);
                    from.setDate(yesterday.getDate() - i - 1);
                }

                createGraph("g1", "Percentage of failures per day", labels, [{
                        data: points,
                        borderColor: "rgba(24, 42, 94, 0.8)",
                        fill: false,
                    }, {
                        data: Array(days + 1).fill(10),
                        borderColor: "rgba(1, 2, 3, 0.3)",
                        fill: false,
                    }]);

                const all = db.exec(`
                        SELECT COUNT(*) AS failed
                        FROM TestRuns
                        JOIN Tests ON Tests.run = TestRuns.id
                        WHERE time > ${since} AND Tests.testname = '${test}'`)[0].values[0][0];
                document.getElementById("description").innerHTML = `Showing results from ${all} tests (${failed} failed).`;
            } else {
                const prs_count = db.exec(`
                    SELECT COUNT(DISTINCT(revision))
                    FROM TestRuns
                    WHERE time > ${since}`)[0].values[0][0];
                const tests_count = db.exec(`
                    SELECT COUNT(*)
                    FROM Tests
                    JOIN TestRuns ON Tests.run = TestRuns.id
                    WHERE time > ${since}`)[0].values[0][0];
                document.getElementById("description").innerHTML = `Showing results from ${prs_count} PRs and ${tests_count} tests.`;

                // Select unexpected messages
                let messages = db.exec(`
                    SELECT retry_reason, TestRuns.url
                    FROM Tests
                    JOIN TestRuns ON Tests.run = TestRuns.id
                    WHERE TestRuns.time > ${since} AND
                        retry_reason IS NOT null AND
                        retry_reason IS NOT 'be robust against unstable tests' AND
                        retry_reason IS NOT 'due to failure of test harness or framework'`);
                if (messages.length)
                    messages = messages[0].values.reduce((a, m) => {if (m) a.push([m[0], m[1]]); return a;}, []);

                // Replace any numbers > 100 with 0 (usually time stamps or PIDs)
                messages = messages.map(m => [m[0].replace(/\d\d[\d\.]+/, '0'), m[1]]);

                // Replace any partial paths like dracut.xf8hG with dracut.xxx
                messages = messages.map(m => [m[0].replace(/(\/[^\/ \t]{3,}\.)[^\/ \t]+/, "$1xxx"), m[1]]);

                const counter = messages.reduce((counter, m) => {
                    counter[m[0]] = ++counter[m[0]] || 1;
                    return counter;
                }, {});

                const data = [];
                Object.keys(counter).forEach(m => {
                    if (counter[m] > 1) { // Don't show message that happened just once
                        logs = messages.reduce((a, mx) => {if (mx[0] === m && a.indexOf(mx[1]) < 0) a.push(mx[1]); return a;}, []).splice(0, 2);
                        data.push([m, counter[m], logs]);
                    }
                });
                data.sort((a, b) => a[1] < b[1]);

                if (data.length > 0)
                    createTable("t2", "Unexpected messages", ["Message", "Count", "Logs"], data);

                // Get all failures sorted by number of occurrences
                top10 = []
                const rows = db.exec(`
                        SELECT t1.testname, (t2.failed * 100.0) / COUNT(run) AS percent
                        FROM Tests AS t1
                        JOIN TestRuns ON t1.run = TestRuns.id
                        JOIN (
                            SELECT testname, COUNT(run) as failed
                            FROM Tests
                            JOIN TestRuns ON Tests.run = TestRuns.id
                            WHERE TestRuns.time > ${since} AND Tests.failed = 1
                            GROUP BY testname
                        ) AS t2 ON t1.testname = t2.testname
                        WHERE TestRuns.time > ${since} AND t2.failed > 0
                        GROUP BY t1.testname
                        ORDER BY percent DESC
                        LIMIT 10`);

                rows[0].values.forEach(row => {
                    const urls = db.exec(`
                        SELECT DISTINCT TestRuns.url
                        FROM TestRuns JOIN Tests ON TestRuns.id = Tests.run
                        WHERE testname = '${row[0]}' AND failed = 1
                        ORDER BY run DESC
                        LIMIT 2`);
                    const links = urls[0].values.map(u => u[0]);
                    top10.push([{name: row[0], key: "test"}, row[1].toFixed(2), links]);
                });

                if (!top10.length)
                    top10.push([`No failures in the last ${days} days`, 0, []]);

                createTable("t1", "Top failures", ["Test name", "Fail rate (%)", "Logs"], top10);

                // Show average waiting time in queue per day
                const wait_points = [];
                const wait_labels = [];
                const pr_labels = [];
                const pr_points = [];
                let max = 0;
                let all = 0;
                const yesterday = new Date();
                yesterday.setHours(0, 0, 0, 0);
                let to = new Date();
                let from = yesterday;
                for (let i = 0; i < days; i++) {
                    const time = db.exec(`
                            SELECT SUM(wait_seconds) / COUNT(*), COUNT(*)
                            FROM TestRuns
                            WHERE time > ${from.getTime() / 1000} AND time < ${to.getTime() / 1000}`);
                    wait_points.unshift(time[0].values[0][0]);
                    wait_labels.unshift(`${from.getDate()}.${from.getMonth() + 1} (${time[0].values[0][1]} runs)`);

                    const prs = db.exec(`
                                SELECT revision, context, state, MAX(retry) as top
                                FROM TestRuns
                                WHERE time > ${from.getTime() / 1000} AND time < ${to.getTime() / 1000}
                                GROUP BY revision, context`);
                    if (prs.length) {
                        shas = {};
                        prs[0].values.forEach(i => {
                            if (i[2] !== "success")
                                shas[i[0]] = -1;
                            else if (shas[i[0]] !== -1) // No context failed
                                shas[i[0]] = Math.max(shas[i[0]] || 0, i[3]);
                        });
                        all = Object.keys(shas).length;
                        let red = 0; // Merged with failed test
                        let orange = 0; // Merged green with one max one retry
                        let green = 0; // Merged green without any retry
                        Object.values(shas).forEach(v => {
                            if (v === -1) red++;
                            else if (v === 0) green++;
                            else if (v === 1) orange++;
                        });
                        pr_points.unshift([(orange * 100) / all, ((all - green - orange - red) * 100) / all, (red * 100) / all]);
                        max = Math.max(max, 100 - (green * 100) / all);
                    } else {
                        all = 0;
                        pr_points.unshift([0, 0, 0]);
                    }

                    pr_labels.unshift(`${from.getDate()}.${from.getMonth() + 1} (${all} PRs)`);

                    to = new Date(yesterday);
                    to.setDate(yesterday.getDate() - i);
                    from = new Date(yesterday);
                    from.setDate(yesterday.getDate() - i - 1);
                }

                createGraph("g1", "Pull requests semaphore", pr_labels, [{
                        data: Array(days + 1).fill(10),
                        borderColor: "rgba(50, 150, 50, 0.3)",
                        fill: false,
                        label: "Limit for one retry",
                        yAxisID: "limit",
                    }, {
                        data: Array(days + 1).fill(5),
                        borderColor: "rgba(120, 120, 50, 0.3)",
                        fill: false,
                        label: "Limit for any retry",
                        yAxisID: "limit",
                    }, {
                        data: pr_points.map(p => p[2]),
                        borderColor: "rgba(180, 25, 52, 0.8)",
                        backgroundColor: "rgba(180, 25, 52, 0.8)",
                        label: "Merged red",
                        yAxisID: "main",
                    }, {
                        data: pr_points.map(p => p[1]),
                        borderColor: "rgba(180, 100, 25, 0.8)",
                        backgroundColor: "rgba(180, 100, 25, 0.8)",
                        label: "Green with 2+ retries",
                        yAxisID: "main",
                    }, {
                        data: pr_points.map(p => p[0]),
                        borderColor: "rgba(180, 180, 25, 0.8)",
                        backgroundColor: "rgba(180, 180, 25, 0.8)",
                        label: "Green with 1 retry",
                        yAxisID: "main",
                    }], {
                        scales: {
                            yAxes: [{
                                id: "limit",
                                display: false,
                                ticks: {
                                    min: 0,
                                    max: max,
                                },
                            }, {
                                id: "main",
                                stacked: true,
                                ticks: {
                                    min: 0,
                                    max: max,
                                },
                                scaleLabel: {
                                    display: true,
                                    labelString: "% (stacked)",
                                },
                            }]
                        },
                        responsive: false,
                    });

                createGraph("g2", "Average time waiting in queue (s)", wait_labels, [{
                        data: wait_points,
                        borderColor: "rgba(24, 42, 94, 0.8)",
                        fill: false,
                    }, {
                        data: Array(days + 1).fill(300),
                        borderColor: "rgba(1, 2, 3, 0.3)",
                        fill: false,
                    }]);
            }
        };
        xhr.send();
    });

    function createGraph(id, name, labels, datasets, options) {
        document.getElementById(id).innerHTML = "";
        document.getElementById(id + "-title").innerHTML = name;

        if (!options)
            options = {
                legend: {
                    display: false,
                },
                responsive: false,
            };

        // Create graph itself
        const ctx = document.getElementById(id);
        const chart = new Chart(ctx, {
            type: "line",
            data: {
                labels: labels,
                datasets: datasets,
            },
            options: options,
        });
    }

    function createTable(id, name, columns, data) {
        const wrapper = document.createElement("DIV");

        // Create title of the table
        const title = document.createElement("H2");
        title.textContent = name;
        wrapper.appendChild(title);

        // Create table itself
        const table = document.createElement("TABLE");
        table.className="table table-striped";

        // Create heading
        const head = document.createElement("THEAD");
        let row = document.createElement("TR");
        columns.forEach(c => {
            const th = document.createElement("TH");
            th.textContent = c;
            row.appendChild(th);
        });
        head.appendChild(row);
        table.appendChild(head);

        // Fill the table with data
        const body = document.createElement("TBODY");
        data.forEach(r => {
            row = document.createElement("TR");
            r.forEach(d => {
                // Array with logs
                const td = document.createElement("TD");
                if (d instanceof Array) {
                    d.forEach(a => {
                        const ea = document.createElement("A");
                        ea.className="btn btn-link py-0";
                        ea.textContent = "log";
                        ea.href = a;
                        td.appendChild(ea);
                    });
                } else if (typeof d == "object") {
                    const ea = document.createElement("A");
                    ea.className="btn btn-link py-0";
                    ea.textContent = d.name;
                    ea.href="#";
                    ea.onclick = () => {
                        params.set(d.key, d.name);
                        history.replaceState(null, null, "?"+params.toString());
                        location.reload();
                    };
                    td.appendChild(ea);
                } else {
                    td.textContent = d;
                }
                row.appendChild(td);
            });
            body.appendChild(row);
        });
        table.appendChild(body);

        wrapper.appendChild(table);
        document.getElementById(id).innerHTML = "";
        document.getElementById(id).appendChild(wrapper);
    }
  </script>
</html>
