<meta charset="utf8" />
<head>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css">
    <script src='https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.2.1/dist/sql-wasm.js'></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@2.8.0"></script>
</head>
<html>
    <body>
        <div class="d-flex justify-content-between flex-md-row align-items-center p-3 px-md-4 mb-3 bg-white border-bottom box-shadow">
            <div>
                <h4 class="my-0 mr-md-auto font-weight-normal">CI Weather Report</h4>
                <small>Brought to you by <b>MM</b></small>
            </div>
            <div class="form-group row">
                <label for="days" class="col-sm-6 col-form-label">Days</label>
                <select id="days" class="form-control col-sm-6">
                    <option value="3">3</option>
                    <option value="5">5</option>
                    <option value="7">7</option>
                    <option value="9">9</option>
                    <option value="14">14</option>
                    <option value="21">21</option>
                </select>
            </div>
        </div>
        <nav aria-label="breadcrumb" id="nav" hidden>
            <ol class="breadcrumb">
                <li class="breadcrumb-item"><a href="#" id="overview">Overview</a></li>
                <li class="breadcrumb-item active" aria-current="page" id="current"></li>
            </ol>
        </nav>
        <div class="container-fluid px-5">
            <div class="row">
                <div class="col-md-6">
                    <div id="t1"></div>
                </div>
                <div class="col-md-6">
                    <div id="t2"></div>
                </div>
            </div>
            <div class="row">
                <div class="col-md-12">
                    <h2 id="g1-title"></h2>
                    <canvas id="g1" style="width: 100%; height: 256px"></canvas>
                </div>
            </div>
            <div class="row">
                <div class="col-md-12">
                    <h2 id="g2-title"></h2>
                    <canvas id="g2" style="width: 100%; height: 256px"></canvas>
                </div>
            </div>
        </div>
  </body>
  <script>
    const DAY = 86400;
    const params = new URLSearchParams(window.location.search);
    const days = params.get('days') || 14;
    const test = params.get('test');

    const days_select = document.getElementById("days");
    Array.from(days_select.options).forEach(o => {
        o.selected = o.value == days;
    });
    days_select.addEventListener("change", e => {
        params.set("days", e.target.value);
        history.replaceState(null, null, "?"+params.toString());
        location.reload();
    });

    if (test) {
        document.getElementById("nav").hidden = false;
        document.getElementById("current").innerHTML = test;
        document.getElementById("overview").onclick = () => {
            params.delete("test");
            history.replaceState(null, null, "?"+params.toString());
            location.reload();
        };
    } else {
        document.getElementById("nav").hidden = true;
    }

    const config = {
      locateFile: filename => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.2.1/dist/${filename}`
    };
    initSqlJs(config).then(SQL => {
        const xhr = new XMLHttpRequest();
        xhr.open('GET', 'test-results.db', true);
        xhr.responseType = 'arraybuffer';

        xhr.onload = e => {
            const uInt8Array = new Uint8Array(xhr.response);
            const db = new SQL.Database(uInt8Array);

            const since = (new Date().getTime() / 1000) - days * DAY;

            if (test) {
                top10 = []
                const rows = db.exec(`
                        SELECT context, COUNT(*) AS failed
                        FROM TestRuns
                        JOIN Tests ON Tests.run = TestRuns.id
                        WHERE time > ${since} AND Tests.failed = 1 AND Tests.testname = '${test}'
                        GROUP BY context
                        ORDER BY COUNT(*) DESC`);
                const all = db.exec(`
                        SELECT COUNT(*) AS failed
                        FROM TestRuns
                        JOIN Tests ON Tests.run = TestRuns.id
                        WHERE time > ${since} AND Tests.failed = 1 AND Tests.testname = '${test}'`)[0].values[0][0];

                rows[0].values.forEach(row => {
                    const urls = db.exec(`
                        SELECT DISTINCT TestRuns.url
                        FROM TestRuns JOIN Tests ON TestRuns.id = Tests.run
                        WHERE testname = '${test}' AND TestRuns.context = '${row[0]}' AND failed = 1
                        ORDER BY run DESC
                        LIMIT 2`);
                    const links = urls[0].values.map(u => u[0]);
                    top10.push([row[0], ((row[1] * 100) / all).toFixed(2), links]);
                });
                if (!top10.length)
                    top10.push([`No failures in the last ${days} days`, 0, []]);

                createTable("t1", "Most affected OSes", ["Operating system", "Fail rate (%)", "Logs"], top10);
            } else {
                // Select unexpected messages
                let messages = db.exec(`
                    SELECT retry_reason, TestRuns.url
                    FROM Tests
                    JOIN TestRuns ON Tests.run = TestRuns.id
                    WHERE TestRuns.time > ${since} AND
                        retry_reason IS NOT null AND
                        retry_reason IS NOT 'be robust against unstable tests' AND
                        retry_reason IS NOT 'due to failure of test harness or framework'`);
                if (messages.length)
                    messages = messages[0].values.reduce((a, m) => {if (m) a.push([m[0], m[1]]); return a;}, []);

                // Replace any numbers > 100 with 0 (usually time stamps or PIDs)
                messages = messages.map(m => [m[0].replace(/\d\d[\d\.]+/, '0'), m[1]]);

                // Replace any partial paths like dracut.xf8hG with dracut.xxx
                messages = messages.map(m => [m[0].replace(/(\/[^\/ \t]{3,}\.)[^\/ \t]+/, "$1xxx"), m[1]]);

                const counter = messages.reduce((counter, m) => {
                    counter[m[0]] = ++counter[m[0]] || 1;
                    return counter;
                }, {});

                const data = [];
                Object.keys(counter).forEach(m => {
                    if (counter[m] > 1) { // Don't show message that happened just once
                        logs = messages.reduce((a, mx) => {if (mx[0] === m && a.indexOf(mx[1]) < 0) a.push(mx[1]); return a;}, []).splice(0, 2);
                        data.push([m, counter[m], logs]);
                    }
                });
                data.sort((a, b) => a[1] < b[1]);

                if (data.length > 0)
                    createTable("t2", "Unexpected messages", ["Message", "Count", "Logs"], data);

                // Get all failures sorted by number of occurrences
                top10 = []
                const rows = db.exec(`
                        SELECT t1.testname, (t2.failed * 100.0) / COUNT(run) AS percent
                        FROM Tests AS t1
                        JOIN TestRuns ON t1.run = TestRuns.id
                        JOIN (
                            SELECT testname, COUNT(run) as failed
                            FROM Tests
                            JOIN TestRuns ON Tests.run = TestRuns.id
                            WHERE TestRuns.time > ${since} AND Tests.failed = 1
                            GROUP BY testname
                        ) AS t2 ON t1.testname = t2.testname
                        WHERE TestRuns.time > ${since} AND t2.failed > 0
                        GROUP BY t1.testname
                        ORDER BY percent DESC
                        LIMIT 10`);

                rows[0].values.forEach(row => {
                    const urls = db.exec(`
                        SELECT DISTINCT TestRuns.url
                        FROM TestRuns JOIN Tests ON TestRuns.id = Tests.run
                        WHERE testname = '${row[0]}' AND failed = 1
                        ORDER BY run DESC
                        LIMIT 2`);
                    const links = urls[0].values.map(u => u[0]);
                    top10.push([{name: row[0], key: "test"}, row[1].toFixed(2), links]);
                });

                if (!top10.length)
                    top10.push([`No failures in the last ${days} days`, 0, []]);

                createTable("t1", "Top failures", ["Test name", "Fail rate (%)", "Logs"], top10);

                // Show average waiting time in queue per day
                const labels = [];
                const points = [];
                const limit_points = [];
                const yesterday = new Date();
                yesterday.setHours(0, 0, 0, 0);
                for (let i = 0; i < days; i++) {
                    const to = new Date(yesterday);
                    to.setDate(yesterday.getDate() - i);
                    const since = new Date(yesterday);
                    since.setDate(yesterday.getDate() - i - 1);
                    const time = db.exec(`
                            SELECT SUM(wait_seconds) / COUNT(*)
                            FROM TestRuns
                            WHERE time > ${since.getTime() / 1000} AND time < ${to.getTime() / 1000}`);
                    labels.unshift(since.getDate() + "." + (since.getMonth() + 1));
                    points.unshift(time[0].values[0]);
                    limit_points.push(300);
                }
                createGraph("g2", "Average time waiting in queue (s)", labels, points, limit_points);
            }

            // Show % of failed tests per day
            const labels = [];
            const points = [];
            const limit_points = [];
            const yesterday = new Date();
            yesterday.setHours(0, 0, 0, 0);
            for (let i = 0; i < days; i++) {
                const to = new Date(yesterday);
                to.setDate(yesterday.getDate() - i);
                const since = new Date(yesterday);
                since.setDate(yesterday.getDate() - i - 1);
                let tq = "";
                if (test)
                    tq = ` AND Tests.testname = '${test}' `;
                const failed = db.exec(`
                        SELECT (t2.count * 100.0) / COUNT(*) AS percent
                        FROM Tests
                        JOIN TestRuns ON Tests.run = TestRuns.id
                        JOIN (
                            SELECT COUNT(*) as count
                            FROM Tests
                            JOIN TestRuns ON Tests.run = TestRuns.id
                            WHERE TestRuns.time > ${since.getTime() / 1000} AND TestRuns.time < ${to.getTime() / 1000} AND Tests.failed = 1${tq}
                        ) AS t2
                        WHERE TestRuns.time > ${since.getTime() / 1000} AND TestRuns.time < ${to.getTime() / 1000}${tq}`);
                labels.unshift(since.getDate() + "." + (since.getMonth() + 1));
                points.unshift(failed[0].values[0]);
                limit_points.push(10);
            }
            let label = "Percentage of failed tests per day";
            if (test)
                label = "Percentage of failures per day";

            createGraph("g1", label, labels, points, limit_points);
        };
        xhr.send();
    });

    function createGraph(id, name, labels, points, limit_points) {
        document.getElementById(id).innerHTML = "";
        document.getElementById(id + "-title").innerHTML = name;

        // Create graph itself
        const ctx = document.getElementById(id);
        const chart = new Chart(ctx, {
            type: "line",

            data: {
                labels: labels,
                datasets: [{
                    data: points,
                    borderColor: "rgba(24, 42, 94, 0.8)",
                    fill: false,
                }, {
                    data: limit_points,
                    borderColor: "rgba(1, 2, 3, 0.3)",
                    fill: false,
                }]
            },

            options: {
                legend: {
                    display: false,
                },
                responsive: false,
            }
        });
    }

    function createTable(id, name, columns, data) {
        const wrapper = document.createElement("DIV");

        // Create title of the table
        const title = document.createElement("H2");
        title.textContent = name;
        wrapper.appendChild(title);

        // Create table itself
        const table = document.createElement("TABLE");
        table.className="table table-striped";

        // Create heading
        const head = document.createElement("THEAD");
        let row = document.createElement("TR");
        columns.forEach(c => {
            const th = document.createElement("TH");
            th.textContent = c;
            row.appendChild(th);
        });
        head.appendChild(row);
        table.appendChild(head);

        // Fill the table with data
        const body = document.createElement("TBODY");
        data.forEach(r => {
            row = document.createElement("TR");
            r.forEach(d => {
                // Array with logs
                const td = document.createElement("TD");
                if (d instanceof Array) {
                    d.forEach(a => {
                        const ea = document.createElement("A");
                        ea.className="btn btn-link py-0";
                        ea.textContent = "log";
                        ea.href = a;
                        td.appendChild(ea);
                    });
                } else if (typeof d == "object") {
                    const ea = document.createElement("A");
                    ea.className="btn btn-link py-0";
                    ea.textContent = d.name;
                    ea.href="#";
                    ea.onclick = () => {
                        params.set(d.key, d.name);
                        history.replaceState(null, null, "?"+params.toString());
                        location.reload();
                    };
                    td.appendChild(ea);
                } else {
                    td.textContent = d;
                }
                row.appendChild(td);
            });
            body.appendChild(row);
        });
        table.appendChild(body);

        wrapper.appendChild(table);
        document.getElementById(id).innerHTML = "";
        document.getElementById(id).appendChild(wrapper);
    }
  </script>
</html>
