#!/usr/bin/env python3
# SPDX-License-Identifier: GPL-3.0-or-later

"""image-create - Make a root image suitable for use with vm-run.

Installs the OS indicated by TEST_OS into the image for test machine and tweaks
it to be useable with vm-run and testlib.py.
"""

import argparse
import asyncio
import contextlib
import hashlib
import os
import tempfile
from collections.abc import Mapping
from pathlib import Path

from lib import testthing
from lib.aio.jsonutil import JsonObject
from lib.constants import IMAGES_DIR, MACHINE_DIR, SCRIPTS_DIR
from lib.directories import get_images_data_dir

WORKAROUNDS = Path(SCRIPTS_DIR) / 'test.thing-workarounds'


def format_journal_line(entry: Mapping[str, str]) -> str:
    def one_of(*keys: str, default: str) -> str:
        return next(filter(None, (entry.get(k) for k in keys)), default)

    stamp = one_of(
        "_SOURCE_BOOTTIME_TIMESTAMP",
        "_SOURCE_MONOTONIC_TIMESTAMP",
        "__MONOTONIC_TIMESTAMP",
        default="0",
    )
    if entry["_TRANSPORT"].lower() == "kernel":
        ident = "kernel"
    else:
        name = one_of("SYSLOG_IDENTIIFIER", "_COMM", "_EXE", default="?")
        pid = one_of("SYSLOG_PID", "_PID", default="?")
        ident = f"{name}[{pid}]"

    return f"[{float(stamp) / 1_000_000:+.6f}] {ident}: {entry['MESSAGE']}"


def print_journal_line(entry: Mapping[str, str]) -> None:
    if entry.get('PRIORITY', '9') in '012345678' or 'ssh' in entry.get('SYSLOG_IDENTIFIER', ""):  # 4 = "Warning"
        with contextlib.suppress(OSError):
            print(format_journal_line(entry))


def cloud_init_config(image: str) -> JsonObject | None:
    def extra_file(dest: str) -> JsonObject:
        source = WORKAROUNDS / Path(dest).name
        return {
            "path": dest,
            "content": source.read_text(),
            "permissions": "0755" if os.access(source, os.X_OK) else "0644",
        }

    # don't cloud-init images that we already used ignition for
    if image in ['centos-9-bootc', 'fedora-coreos', 'services']:
        return None

    ssh_authorized_keys = [Path(MACHINE_DIR, "identity.pub").read_text()]
    host_key = Path(MACHINE_DIR, "host_key").read_text()
    host_key_pub = Path(MACHINE_DIR, "host_key.pub").read_text()

    bootcmd = []
    write_files = {"/usr/bin/vsock-fling"}  # weeeee
    runcmd = []

    # TODO: filter this?
    runcmd.append("echo 100::55:4e4b:4e4f:574e UNKNOWN >> /etc/hosts")

    if image == 'arch':
        bootcmd.append("systemctl disable --now systemd-time-wait-sync.service")

    openrc = image.startswith('alpine')
    if openrc:
        # ssh-vsock support for OpenRC
        write_files.add("/usr/local/sbin/tt-vsock-sshd")
        write_files.add("/etc/init.d/tt-vsock-ssh-service")
        runcmd.append("rc-update add tt-vsock-ssh-service default")
        runcmd.append("rc-service tt-vsock-ssh-service start")

        # do this one last: it notifies that we're done
        runcmd.append("vsock-fling 2 1111 X_SYSTEMD_UNIT_ACTIVE=multi-user.target")

    else:
        # systemd

        if image.startswith(("centos-9-", "rhel-8-", "rhel-9-", "ubuntu-22", "ubuntu-24")):
            # no `vmm.notify_socket`, `systemd-ssh-generator` `ssh-vsock.socket` support

            if image.startswith(("centos-", "rhel-")):
                # SELinux vsock fixes: https://issues.redhat.com/browse/RHEL-113647
                # We need to apply these *before* we can start the socket unit...
                print("Updating SELinux policy can take a long time... please be patient.")
                write_files.add("/tmp/tt-ssh-vsock-selinux.sh")
                runcmd.append("/tmp/tt-ssh-vsock-selinux.sh")

            write_files.update({
                "/etc/systemd/system/tt-sd_notify.service",
                "/etc/systemd/system/tt-sshd-vsock.socket",
                "/etc/systemd/system/tt-sshd-vsock@.service",
            })
            runcmd.extend([
                r"systemctl daemon-reload",
                r"systemctl enable --now tt-sshd-vsock.socket",
                r"systemctl enable tt-sd_notify.service",
            ])

            # do this one last: it notifies that we're done
            runcmd.append("vsock-fling 2 1111 X_SYSTEMD_UNIT_ACTIVE=multi-user.target")

    return {
        "users": [
            "default",
            {
                "name": "root",
                "lock_passwd": False,
                "plain_text_passwd": "foobar",
                "groups": "users,wheel",
                "ssh_authorized_keys": ssh_authorized_keys,
            },
            {
                "name": "admin",
                "lock_passwd": False,
                "plain_text_passwd": "foobar",
                "gecos": "Administrator",
                "primary_group": "admin",
                "groups": "users,wheel",
                "ssh_authorized_keys": ssh_authorized_keys,
            },
        ],
        "ssh_pwauth": True,
        "ssh_keys": {
            "rsa_private": host_key,
            "rsa_public": host_key_pub,
        },
        "bootcmd": [("sh", "-c", cmd) for cmd in bootcmd],
        "write_files": [extra_file(file) for file in write_files],
        "runcmd": [("sh", "-c", cmd) for cmd in runcmd],
        "cloud_final_modules": [
            "scripts-per-once",
            "scripts-per-boot",
            "scripts-per-instance",
            ["scripts-user", "always"],
            "final-message",
        ],
    }


class ImageCreate:
    def __init__(self, *, image: str, no_build: bool, sit: bool, verbose: bool) -> None:
        self.ui = testthing.UI(status_messages=True, verbose=verbose)

        if image in ["fedora-coreos", "services"] and not no_build:
            self.ui.print_verbose("Creating machine without build capabilities based on the image type")
            no_build = True

        self.image = image
        self.no_build = no_build
        self.sit = sit

        if image.endswith('boot'):
            self.suffix = 'iso'
        elif image.endswith('payload'):
            self.suffix = 'tar.gz'
        else:
            self.suffix = 'qcow2'

    def heading(self, text: str) -> None:
        self.ui.print(f"\n\033[1m## {text}\033[0m\n")

    async def bootstrap(self, tmpfile: Path) -> None:
        self.heading("Run bootstrap script on host")
        bootstrap_script = Path(SCRIPTS_DIR) / f"{self.image}.bootstrap"
        await self.ui.run(bootstrap_script, tmpfile)

    async def setup(self, tmpfile: Path) -> None:
        scripts = Path(SCRIPTS_DIR)
        setup_script = scripts / f"{self.image}.setup"
        if not setup_script.exists():
            self.heading("No additional setup required")
            return

        self.heading("Start guest")
        cockpit_test_identity = Path(MACHINE_DIR) / "identity"
        cockpit_test_identity.chmod(0o600)

        cockpit_test_identity_pub = Path(MACHINE_DIR) / "identity.pub"

        # deploying candlepin needs oodles of memory
        memory = "3072M" if self.image in ["services"] else "2048M"

        cloud_init_user_data = cloud_init_config(self.image)

        with testthing.IpcDirectory() as ipc:
            async with testthing.VirtualMachine(
                # attach_console=True,
                cloud_init_user_data=cloud_init_user_data,
                boot="mbr" if self.image in ['alpine'] else "efi",
                credentials={
                    # "ssh.authorized_keys.root": cockpit_test_identity_pub.read_text().strip(),
                    "passwd.plaintext-password.root": "foobar",
                },
                identity=(cockpit_test_identity, None),
                image=tmpfile,
                ipc=ipc,
                journal=print_journal_line,
                memory=memory,
                networks=[testthing.Network("user")],
                snapshot=False,
                sit=self.sit,
                target="multi-user.target",
                timeout=120,
                ui=self.ui,
            ) as vm:
                self.heading("Run setup script on guest")

                await vm.scp("-r", scripts / "lib", "vm:/var/lib/testvm")
                await vm.scp("-r", setup_script, "vm:/var/tmp/SETUP")
                await vm.execute(
                    "/var/tmp/SETUP",
                    self.image,
                    environment={
                        "TEST_OS": self.image,
                        "DO_BUILD": "0" if self.no_build else "1",
                        "SERVER_REPO_URL": os.environ.get("SERVER_REPO_URL", ""),
                        "EXTRAS_REPO_URL": os.environ.get("EXTRAS_REPO_URL", ""),
                        "BASEOS_REPO_URL": os.environ.get("BASEOS_REPO_URL", ""),
                        "APPSTREAM_REPO_URL": os.environ.get("APPSTREAM_REPO_URL", ""),
                    },
                    stdout=None,
                )

                self.heading("Shutting down guest")

    async def save(self, tmpfile: Path) -> None:
        self.heading("Saving image")
        data_dir = Path(get_images_data_dir())
        data_dir.mkdir(exist_ok=True, mode=0o750, parents=True)

        with tempfile.NamedTemporaryFile(
            dir=data_dir,
            prefix=f"{self.image}-",
            suffix=".tmp.{self.suffix}",
            delete_on_close=False,
        ) as tmp:
            # Copy image via convert, to make it sparse again
            tmp_data_file = Path(tmp.name)

            if self.suffix == 'qcow':
                # re-sparseify
                await self.ui.run(
                    ("qemu-img", "convert"),
                    ("-f", "qcow2", tmpfile),
                    ("-O", "qcow2", "-c", tmp_data_file),
                )
            else:
                # copy from the tmpdir to the datadir
                await self.ui.run('cp', tmpfile, tmp_data_file)

            # Hash the image here
            with tmp_data_file.open("rb") as fp:
                sha = hashlib.file_digest(fp, "sha256").hexdigest()
                name = f"{self.image}-{sha}.{self.suffix}"

            # a simple rename always works because it's the same directory
            final_data_file = data_dir / name
            self.ui.print_verbose(f"~ mv \\\n      {final_data_file} \\\n      {name}\n")
            tmp_data_file.rename(final_data_file)
            tmp.close()

        images_dir = Path(IMAGES_DIR)

        self.ui.print_verbose(f"~ ln -sf \\\n      {final_data_file} \\\n      {images_dir}/\n")
        (images_dir / name).unlink(missing_ok=True)
        (images_dir / name).symlink_to(final_data_file)

        self.ui.print_verbose(f"~ ln -sf \\\n      {name} \\\n      {images_dir}/{self.image}\n")
        (images_dir / self.image).unlink(missing_ok=True)
        (images_dir / self.image).symlink_to(name)

    async def create(self) -> None:
        with tempfile.NamedTemporaryFile(
            dir="/var/tmp", prefix=f"cockpit-image-create-{self.image}-", suffix=f".tmp.{self.suffix}"
        ) as tmp:
            tmpfile = Path(tmp.name)
            await self.bootstrap(tmpfile)
            await self.setup(tmpfile)
            await self.save(tmpfile)


def main() -> None:
    parser = argparse.ArgumentParser(description="Create a virtual machine image")
    parser.add_argument("-v", "--verbose", action="store_true", help="Display verbose progress details")
    parser.add_argument("-s", "--sit", action="store_true", help="Sit and wait if setup script fails")
    parser.add_argument("--no-build", action="store_true", help="Create the VM without build capabilities")
    parser.add_argument("image", help="The image to create")
    args = parser.parse_args()

    with testthing.cli_helper():
        asyncio.run(ImageCreate(**vars(args)).create())


if __name__ == "__main__":
    main()
