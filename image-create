#!/usr/bin/env python3
# SPDX-License-Identifier: GPL-3.0-or-later

"""image-create - Make a root image suitable for use with vm-run.

Installs the OS indicated by TEST_OS into the image for test machine and tweaks
it to be useable with vm-run and testlib.py.
"""

import argparse
import asyncio
import hashlib
import os
import tempfile
from pathlib import Path

from lib import testthing
from lib.aio.jsonutil import JsonObject
from lib.constants import IMAGES_DIR, MACHINE_DIR, SCRIPTS_DIR
from lib.directories import get_images_data_dir


def cloud_init_config(image: str) -> JsonObject:
    vm_pass = "$5$CockpitCloudInit$Iw89f.aPgqHPXAHC2Zs9h9335n3E1FQDFvR6MLqwPK9"
    ssh_authorized_keys = [Path(MACHINE_DIR, "identity.pub").read_text()]
    host_key = Path(MACHINE_DIR, "host_key").read_text()
    host_key_pub = Path(MACHINE_DIR, "host_key.pub").read_text()

    bootcmd = []
    runcmd = ["printf X_SYSTEMD_UNIT_ACTIVE=los-gehts > /dev/virtio-ports/tt-notify"]

    if image in ["arch", "centos-9-bootc"]:
        bootcmd.append("echo 100::55:4e4b:4e4f:574e UNKNOWN >> /etc/hosts")

    if image in ["arch"]:
        bootcmd.append("systemctl disable --now systemd-time-wait-sync.service || true")

    if image in ["opensuse-tumbleweed"]:
        bootcmd.append("echo 'Include /usr/etc/ssh/sshd_config' > /etc/ssh/sshd_config")

    return {
        "users": [
            "default",
            {
                "name": "root",
                "lock_passwd": False,
                "hashed_passwd": vm_pass,
                "groups": "users,wheel",
                "ssh_authorized_keys": ssh_authorized_keys,
            },
            {
                "name": "admin",
                "lock_passwd": False,
                "hashed_passwd": vm_pass,
                "gecos": "Administrator",
                "groups": "users,wheel",
                "ssh_authorized_keys": ssh_authorized_keys,
            },
        ],
        "ssh_pwauth": True,
        "ssh_keys": {
            "rsa_private": host_key,
            "rsa_public": host_key_pub,
        },
        "bootcmd": [("sh", "-c", cmd) for cmd in bootcmd],
        "runcmd": [("sh", "-c", cmd) for cmd in runcmd],
        "cloud_final_modules": [
            "scripts-per-once",
            "scripts-per-boot",
            "scripts-per-instance",
            ["scripts-user", "always"],
            "final-message",
        ],
    }


class ImageCreate:
    def __init__(self, *, image: str, no_build: bool, sit: bool, verbose: bool) -> None:
        self.ui = testthing.UI(status_messages=True, verbose=verbose)

        if image in ["fedora-coreos", "services"] and not no_build:
            self.ui.print_verbose("Creating machine without build capabilities based on the image type")
            no_build = True

        self.image = image
        self.no_build = no_build
        self.sit = sit

    def heading(self, text: str) -> None:
        self.ui.print(f"\n\033[1m## {text}\033[0m\n")

    async def bootstrap(self, tmpfile: Path) -> None:
        self.heading("Run bootstrap script on host")
        bootstrap_script = Path(SCRIPTS_DIR) / f"{self.image}.bootstrap"
        await self.ui.run(bootstrap_script, tmpfile)

    async def setup(self, tmpfile: Path) -> None:
        self.heading("Start guest")
        cockpit_test_identity = Path(MACHINE_DIR) / "identity"
        cockpit_test_identity.chmod(0o600)

        # deploying candlepin needs oodles of memory
        memory = "3072M" if self.image in ["services"] else "2048M"

        with testthing.IpcDirectory() as ipc:
            async with testthing.VirtualMachine(
                boot="mbr",
                cloud_init_user_data=cloud_init_config(self.image),
                identity=(cockpit_test_identity, None),
                image=tmpfile,
                ipc=ipc,
                memory=memory,
                networks=[testthing.Network("user")],
                snapshot=False,
                sit=self.sit,
                target="los-gehts",
                timeout=300,
                ui=self.ui,
            ) as vm:
                scripts = Path(SCRIPTS_DIR)
                await vm.wait_boot()

                self.heading("Run setup script on guest")

                await vm.scp("-r", scripts / "lib", "vm:/var/lib/testvm")
                await vm.scp("-r", scripts / f"{self.image}.setup", "vm:/var/tmp/SETUP")
                await vm.execute(
                    "/var/tmp/SETUP",
                    self.image,
                    environment={
                        "TEST_OS": self.image,
                        "DO_BUILD": "0" if self.no_build else "1",
                        "SERVER_REPO_URL": os.environ.get("SERVER_REPO_URL", ""),
                        "EXTRAS_REPO_URL": os.environ.get("EXTRAS_REPO_URL", ""),
                        "BASEOS_REPO_URL": os.environ.get("BASEOS_REPO_URL", ""),
                        "APPSTREAM_REPO_URL": os.environ.get("APPSTREAM_REPO_URL", ""),
                    },
                    stdout=None,
                )

                self.heading("Shutting down guest")

    async def save(self, tmpfile: Path) -> None:
        self.heading("Saving image")
        data_dir = Path(get_images_data_dir())
        data_dir.mkdir(exist_ok=True, mode=0o750, parents=True)

        with tempfile.NamedTemporaryFile(
            dir=data_dir, prefix=f"{self.image}", suffix=".sparse.qcow2", delete_on_close=False
        ) as tmp:
            # Copy image via convert, to make it sparse again
            sparse = Path(tmp.name)
            await self.ui.run(
                ("qemu-img", "convert"),
                ("-f", "qcow2", tmpfile),
                ("-O", "qcow2", "-c", sparse),
            )

            # Hash the image here
            with sparse.open("rb") as fp:
                sha = hashlib.file_digest(fp, "sha256").hexdigest()
                name = f"{self.image}-{sha}.qcow2"

            # a simple rename always works because it's the same directory
            data_file = data_dir / name
            self.ui.print_verbose(f"~ mv \\\n      {sparse} \\\n      {name}\n")
            sparse.rename(data_file)
            tmp.close()

        images_dir = Path(IMAGES_DIR)

        self.ui.print_verbose(f"~ ln -sf \\\n      {data_file} \\\n      {images_dir}/\n")
        (images_dir / name).unlink(missing_ok=True)
        (images_dir / name).symlink_to(data_file)

        self.ui.print_verbose(f"~ ln -sf \\\n      {name} \\\n      {images_dir}/{self.image}\n")
        (images_dir / self.image).unlink(missing_ok=True)
        (images_dir / self.image).symlink_to(name)

    async def create(self) -> None:
        with testthing.cli_helper(), tempfile.NamedTemporaryFile() as tmp:
            tmpfile = Path(tmp.name)
            await self.bootstrap(tmpfile)
            await self.setup(tmpfile)
            await self.save(tmpfile)


def main() -> None:
    parser = argparse.ArgumentParser(description="Create a virtual machine image")
    parser.add_argument("-v", "--verbose", action="store_true", help="Display verbose progress details")
    parser.add_argument("-s", "--sit", action="store_true", help="Sit and wait if setup script fails")
    parser.add_argument("--no-build", action="store_true", help="Create the VM without build capabilities")
    parser.add_argument("image", help="The image to create")
    args = parser.parse_args()

    asyncio.run(ImageCreate(**vars(args)).create())


if __name__ == "__main__":
    main()
