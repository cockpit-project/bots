#!/usr/bin/env python3
#
# Upload encrypted secrets to GitHub
# With this the secrets can be used by GitHub actions:
# https://developer.github.com/v3/actions/secrets/#create-or-update-an-organization-secret
#
# Secrets are uploaded to the organization by default:
#
#   https://github.com/organizations/cockpit-project/settings/secrets
#
# For testing, you can upload it to a particular project with --receiver OWNER/REPO

#   https://github.com/OWNER/REPO/settings/secrets
#
# This file is part of Cockpit.
#
# Copyright (C) 2020 Red Hat, Inc.
#
# Cockpit is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 2.1 of the License, or
# (at your option) any later version.
#
# Cockpit is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with Cockpit; If not, see <http://www.gnu.org/licenses/>.

import argparse
import os
import re
import sys
import urllib.parse
from base64 import b64encode

from nacl import encoding, public

import task


def encrypt(public_key: str, secret_value: str) -> str:
    """Encrypt a Unicode string using the public key."""

    public_key = public.PublicKey(public_key.encode("utf-8"), encoding.Base64Encoder())
    sealed_box = public.SealedBox(public_key)
    encrypted = sealed_box.encrypt(secret_value.encode("utf-8"))
    return b64encode(encrypted).decode("utf-8")


def main():
    api = task.github.GitHub()

    parser = argparse.ArgumentParser(description='Upload encrypted action secrets to GitHub')
    parser.add_argument('-r', '--receiver', metavar="[ORGNAME | OWNER/REPO]",
                        help="The organization or repository which will receive the secrets; "
                        "default: organization (if available and --env is not given) or repo of current checkout")
    parser.add_argument('-e', '--env', metavar="ENVNAME",
                        help="Upload secrets to given project environment (--receiver must be a project)")
    parser.add_argument('-n', '--dry-run', action="store_true", default=False,
                        help="Only show which secrets would get uploaded where")
    parser.add_argument('-v', '--verbose', action="store_true", default=False,
                        help="Print verbose information")
    parser.add_argument("secrets_dir", help="directory with one file per secret")
    opts = parser.parse_args()

    NAME_RE = r'[a-z][-0-9a-z_.]*'
    REPO_RE = f'{NAME_RE}/{NAME_RE}'

    if opts.receiver and not re.fullmatch(f'{NAME_RE}|{REPO_RE}', opts.receiver, re.I):
        parser.error('--receiver specifies an invalid org or repository name')

    if not opts.receiver:
        if not opts.env:
            # get organization of the current repo, if available
            try:
                opts.receiver = api.get('/repos/' + api.repo)["organization"]["login"]
            except KeyError:
                opts.receiver = api.repo
        else:
            opts.receiver = api.repo

    if '/' in opts.receiver:
        # repository
        resource = '/repos/' + opts.receiver
    else:
        # organization
        resource = '/orgs/' + opts.receiver

    if opts.env:
        # create env if not present already
        env_path = f"{resource}/environments/{urllib.parse.quote(opts.env)}"
        secrets_path = f"{env_path}/secrets"
        if api.get(env_path):
            print(f"Environment {opts.env} already exists")
        else:
            print(f"Creating non-existing environment {opts.env}")
            api.put(env_path, {})
    else:
        secrets_path = f"{resource}/actions/secrets"

    pubkey = api.get(f"{secrets_path}/public-key")

    for secret_name in os.listdir(opts.secrets_dir):
        path = os.path.join(opts.secrets_dir, secret_name)
        if opts.dry_run or opts.verbose:
            print(opts.dry_run and "Would upload" or "Uploading", path, "to", opts.receiver,
                  opts.env and f"environment {opts.env}" or "")
        if opts.dry_run:
            continue
        with open(path) as f:
            enc = encrypt(pubkey["key"], f.read().strip())
        payload = {"key_id": pubkey["key_id"], "encrypted_value": enc, "visibility": "all"}
        api.put(f"{secrets_path}/{secret_name}", payload)

    return 0


if __name__ == '__main__':
    sys.exit(main())
