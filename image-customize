#!/usr/bin/env python3
# This file is part of Cockpit.
#
# Copyright (C) 2015 Red Hat, Inc.
#
# Cockpit is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 2.1 of the License, or
# (at your option) any later version.
#
# Cockpit is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with Cockpit; If not, see <http://www.gnu.org/licenses/>.

import argparse
import os
import sys
import subprocess

from lib.constants import BOTS_DIR, TEST_DIR
from machine import testvm


def prepare_install_image(base_image, install_image, resize):
    '''Create the necessary layered image for the build/install'''

    if "/" not in base_image:
        base_image = os.path.join(testvm.IMAGES_DIR, base_image)
    if "/" not in install_image:
        install_image = os.path.join(os.path.join(TEST_DIR, "images"), os.path.basename(install_image))

    # In vm-customize we don't force recreate images
    if not os.path.exists(install_image):
        install_image_dir = os.path.dirname(install_image)
        os.makedirs(install_image_dir, exist_ok=True)
        base_image = os.path.realpath(base_image)
        qcow2_image = "{0}.qcow2".format(install_image)
        subprocess.check_call(["qemu-img", "create", "-q", "-f", "qcow2",
                               "-o", "backing_file={0},backing_fmt=qcow2".format(base_image), qcow2_image])
        if os.path.lexists(install_image):
            os.unlink(install_image)
        os.symlink(os.path.basename(qcow2_image), install_image)

    if resize:
        subprocess.check_call(["qemu-img", "resize", install_image, resize])

    return install_image


class ActionBase(argparse.Action):
    '''Keep an ordered list of actions'''

    def __call__(self, parser, namespace, value, option_string=None):
        getattr(namespace, self.dest).append((self.execute, value))


class InstallAction(ActionBase):
    '''Install local rpm or distro package'''
    @staticmethod
    def execute(machine_instance, package):
        # this will fail if neither is available -- exception is clear enough, this is a developer tool
        out = machine_instance.execute("which dnf || which yum || which apt-get")
        if 'dnf' in out:
            install_command = "dnf install -y"
        elif 'yum' in out:
            install_command = "yum --setopt=skip_missing_names_on_install=False -y install"
        else:
            install_command = "apt-get install -y"

        if os.path.isfile(package):
            pname = os.path.basename(package)
            dest = "/var/tmp/" + pname
            machine_instance.upload([package], dest)
            package = dest
        elif '/' in package:
            sys.stderr.write("Bad package name or path: %s\n" % package)

        machine_instance.execute(f"{install_command} {package}", timeout=1800)


class RunCommandAction(ActionBase):
    @staticmethod
    def execute(machine_instance, command):
        try:
            machine_instance.execute(command, timeout=1800)
        except subprocess.CalledProcessError as e:
            sys.stderr.write("%s\n" % e)
            sys.exit(e.returncode)


class ScriptAction(ActionBase):
    @staticmethod
    def execute(machine_instance, script):
        if os.path.isfile(script):
            uploadpath = "/var/tmp/" + os.path.basename(script)
            machine_instance.upload([os.path.abspath(script)], uploadpath)
            machine_instance.execute("chmod a+x %s" % uploadpath)
            try:
                machine_instance.execute(uploadpath, timeout=1800)
            except subprocess.CalledProcessError as e:
                sys.stderr.write("%s\n" % e)
                sys.exit(e.returncode)
        else:
            sys.stderr.write("Bad path to script: %s\n" % script)


class UploadAction(ActionBase):
    @staticmethod
    def execute(machine_instance, srcdest):
        src, dest = srcdest.split(":")
        machine_instance.upload([os.path.abspath(src)], dest)


def main():
    parser = argparse.ArgumentParser(
        description=('Run command inside or install packages into a Cockpit virtual machine. '
                     'All actions can be specified multiple times and run in the given order.'))
    # actions (at least one must be given, executed in order)
    parser.add_argument('-i', '--install', action=InstallAction, metavar="PACKAGE", dest='actions', default=[],
                        help='Install package')
    parser.add_argument('-r', '--run-command', action=RunCommandAction, dest='actions',
                        help='Run command inside virtual machine')
    parser.add_argument('-s', '--script', action=ScriptAction, dest='actions',
                        help='Run selected script inside virtual machine')
    parser.add_argument('-u', '--upload', action=UploadAction, metavar="SRC:DEST", dest='actions',
                        help='Upload file/dir to destination file/dir separated by ":" example: -u file.txt:/var/lib')
    # options
    parser.add_argument('--base-image',
                        help='Base image name, if "image" does not match a standard Cockpit VM image name')
    parser.add_argument('--resize', help="Resize the image. Size in bytes with using K, M, or G suffix.")
    parser.add_argument('-n', '--no-network', action='store_true', help='Do not connect the machine to the Internet')
    parser.add_argument('-v', '--verbose', action='store_true',
                        help='Display verbose progress details')
    parser.add_argument('image', help='The image to use (destination name when using --base-image)')
    args = parser.parse_args()

    if not args.actions and not args.resize:
        parser.error("Must specify at least one operation")

    if not args.base_image:
        args.base_image = os.path.basename(args.image)

    args.base_image = testvm.get_test_image(args.base_image)

    if '/' not in args.base_image:
        subprocess.check_call([os.path.join(BOTS_DIR, "image-download"), args.base_image])
    network = testvm.VirtNetwork(0, image=args.base_image)
    machine = testvm.VirtMachine(maintain=True,
                                 verbose=args.verbose,
                                 networking=network.host(restrict=args.no_network),
                                 image=prepare_install_image(args.base_image, args.image, args.resize))
    machine.start()
    machine.wait_boot()
    try:
        for (handler, arg) in args.actions:
            handler(machine, arg)
    finally:
        machine.stop()


if __name__ == '__main__':
    main()
